// Reaper - Rogue Process Watcher
// Pure Ruchy v3.155.0 Implementation
// Single-file architecture with extreme TDD
//
// TICKET: REAPER-106 (REFACTOR phase) - Priority enum documentation
// Status: Improving Priority enum quality (keeping tests GREEN)
//
// This tool automatically detects and terminates rogue processes that consume
// excessive system resources. Based on real production incident (2025-10-31)
// where 17 rogue processes required manual intervention.

// ============================================================================
// DATA STRUCTURES
// ============================================================================

/// Priority represents the urgency level of a detection rule.
///
/// Priorities determine the order in which rogue processes are terminated.
/// Higher priority rules are checked and enforced before lower priority rules.
/// This ensures critical resource protection is prioritized.
///
/// # Variants
/// * `High` - Critical priority (value=3). Processes matching high-priority
///   rules are terminated immediately without grace period. Use for severe
///   resource exhaustion that threatens system stability.
///
/// * `Medium` - Normal priority (value=2). Standard detection rules with
///   normal termination flow (SIGTERM, then SIGKILL after grace period).
///   Use for typical rogue process detection.
///
/// * `Low` - Advisory priority (value=1). Low-priority rules may only log
///   violations rather than terminate. Use for monitoring and alerting
///   without automatic termination.
///
/// # Ordering
/// Priority ordering: High > Medium > Low
///
/// # Usage
/// ```
/// let critical_rule_priority = Priority::High;
/// let standard_rule_priority = Priority::Medium;
///
/// // Compare priorities
/// if is_higher_priority(critical_rule_priority, standard_rule_priority) {
///     println("Critical rule takes precedence");
/// }
///
/// // Convert to string for logging
/// println("Priority: {}", priority_to_string(critical_rule_priority));
/// // Output: "Priority: high"
/// ```
///
/// # Example: Rule Prioritization
/// ```
/// // High priority: Immediate threat to system
/// let memory_bomb = DetectionRule {
///     priority: Priority::High,
///     max_memory_mb: 8192,  // 8GB limit
///     ...
/// };
///
/// // Medium priority: Normal resource control
/// let cpu_hog = DetectionRule {
///     priority: Priority::Medium,
///     max_cpu_percent: 90.0,
///     ...
/// };
///
/// // Low priority: Monitoring only
/// let suspicious_pattern = DetectionRule {
///     priority: Priority::Low,
///     name_pattern: "suspicious.*",
///     ...
/// };
/// ```
enum Priority {
    High,
    Medium,
    Low,
}

/// ProcessStatus represents the current execution state of a process.
/// Maps to Linux process states from /proc/[pid]/stat.
///
/// # Variants
/// * `Running` - Process is actively executing on CPU (state 'R')
/// * `Sleeping` - Process is waiting for I/O or event (state 'S')
/// * `Stopped` - Process has been stopped by signal (state 'T')
/// * `Zombie` - Process terminated but not yet reaped by parent (state 'Z')
enum ProcessStatus {
    Running,
    Sleeping,
    Stopped,
    Zombie,
}

/// Process represents a snapshot of a single process at a point in time.
/// Contains all information needed for detection and termination decisions.
///
/// # Fields
/// * `pid` - Process ID (must be positive, typically 1-32768)
/// * `name` - Process name from /proc/[pid]/comm (max 16 chars in Linux)
/// * `cmdline` - Full command line with arguments from /proc/[pid]/cmdline
/// * `cpu_usage` - CPU usage percentage (0.0-100.0)
/// * `memory_mb` - Memory usage in megabytes (resident set size)
/// * `status` - Current process execution state
///
/// # Validation
/// Use `is_valid_process()` to validate field values after creation.
///
/// # Example
/// ```
/// let proc = new_process(
///     1234,
///     "my_process",
///     "/usr/bin/my_process --flag",
///     45.5,
///     256,
///     ProcessStatus::Running
/// );
/// assert(is_valid_process(proc));
/// ```
struct Process {
    pid: i32,
    name: String,
    cmdline: String,
    cpu_usage: f64,
    memory_mb: i64,
    status: ProcessStatus,
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/// Creates a new Process instance with the given values.
///
/// This constructor does NOT validate inputs. Use `is_valid_process()`
/// after creation to ensure all field values are within valid ranges.
///
/// # Arguments
/// * `pid` - Process ID (should be positive)
/// * `name` - Process name (from /proc/[pid]/comm)
/// * `cmdline` - Full command line (from /proc/[pid]/cmdline)
/// * `cpu_usage` - CPU usage percentage (should be 0.0-100.0)
/// * `memory_mb` - Memory usage in MB (should be non-negative)
/// * `status` - Current process state
///
/// # Returns
/// A new Process instance with the specified values
///
/// # Example
/// ```
/// let proc = new_process(
///     1234,
///     "test",
///     "/usr/bin/test",
///     45.5,
///     256,
///     ProcessStatus::Running
/// );
/// ```
fun new_process(pid: i32, name: String, cmdline: String, cpu_usage: f64, memory_mb: i64, status: ProcessStatus) -> Process {
    Process {
        pid: pid,
        name: name,
        cmdline: cmdline,
        cpu_usage: cpu_usage,
        memory_mb: memory_mb,
        status: status,
    }
}

/// Validates that a Process has valid field values.
///
/// Checks three critical invariants:
/// 1. PID must be positive (> 0)
/// 2. CPU usage must be in range [0.0, 100.0]
/// 3. Memory usage must be non-negative (>= 0)
///
/// # Arguments
/// * `proc` - The Process to validate
///
/// # Returns
/// * `true` if all validations pass
/// * `false` if any validation fails
///
/// # Validation Rules
/// * PID: Must be > 0 (Linux PIDs start at 1, max typically 32768)
/// * CPU: Must be >= 0.0 and <= 100.0 (percentage)
/// * Memory: Must be >= 0 (kernel threads can have 0 memory)
///
/// # Example
/// ```
/// let valid = new_process(1234, "test", "/bin/test", 50.0, 256, ProcessStatus::Running);
/// assert(is_valid_process(valid));
///
/// let invalid = new_process(-1, "bad", "/bin/bad", 50.0, 256, ProcessStatus::Running);
/// assert(!is_valid_process(invalid));
/// ```
fun is_valid_process(proc: Process) -> bool {
    // Validate PID (must be positive)
    // Linux PIDs start at 1, with 0 reserved for scheduler
    if proc.pid <= 0 {
        return false;
    }

    // Validate CPU usage (must be in range [0.0, 100.0])
    // Note: On multi-core systems, individual process usage per core
    // is still capped at 100% in our model
    if proc.cpu_usage < 0.0 || proc.cpu_usage > 100.0 {
        return false;
    }

    // Validate memory (must be non-negative)
    // Kernel threads legitimately have 0 memory usage
    if proc.memory_mb < 0 {
        return false;
    }

    // All validations passed
    true
}

/// Formats a Process as a human-readable string for display.
///
/// Creates a compact string representation including the most important
/// fields for process identification and resource usage monitoring.
///
/// # Arguments
/// * `proc` - The Process to format
///
/// # Returns
/// A formatted string in the format:
/// `"Process[PID=1234, name='test', CPU=45.5%, MEM=256MB]"`
///
/// # Format Details
/// * PID displayed as integer
/// * Name shown in single quotes for clarity
/// * CPU usage with % suffix
/// * Memory with MB suffix
///
/// # Example
/// ```
/// let proc = new_process(9999, "example", "/usr/bin/example", 75.5, 512, ProcessStatus::Running);
/// let output = format_process(proc);
/// // output == "Process[PID=9999, name='example', CPU=75.5%, MEM=512MB]"
/// ```
fun format_process(proc: Process) -> String {
    // Build formatted string with all key process information
    // Format: Process[PID=X, name='Y', CPU=Z%, MEM=WMB]
    let formatted = "Process[PID=";
    formatted = formatted + proc.pid.to_string();
    formatted = formatted + ", name='";
    formatted = formatted + proc.name;
    formatted = formatted + "', CPU=";
    formatted = formatted + proc.cpu_usage.to_string();
    formatted = formatted + "%, MEM=";
    formatted = formatted + proc.memory_mb.to_string();
    formatted = formatted + "MB]";
    formatted
}

/// Converts a Priority to its string representation.
///
/// Returns the priority name in lowercase, suitable for logging,
/// configuration files, and user display.
///
/// # Arguments
/// * `priority` - The Priority variant to convert
///
/// # Returns
/// A lowercase string representation:
/// * `Priority::High` → `"high"`
/// * `Priority::Medium` → `"medium"`
/// * `Priority::Low` → `"low"`
///
/// # Example
/// ```
/// let p = Priority::High;
/// let name = priority_to_string(p);
/// assert(name == "high");
///
/// // Use in logging
/// println("Rule priority: {}", priority_to_string(Priority::Medium));
/// // Output: "Rule priority: medium"
/// ```
///
/// # Use Cases
/// - Logging and audit trails
/// - Configuration file output
/// - User-facing displays
/// - API responses
fun priority_to_string(priority: Priority) -> String {
    match priority {
        Priority::High => "high",
        Priority::Medium => "medium",
        Priority::Low => "low",
    }
}

/// Converts a Priority to its numeric value for sorting and comparison.
///
/// Returns an integer value where higher numbers indicate higher priority.
/// This enables numeric comparison and sorting of priorities.
///
/// # Arguments
/// * `priority` - The Priority variant to convert
///
/// # Returns
/// An integer value representing priority level:
/// * `Priority::High` → `3` (highest)
/// * `Priority::Medium` → `2`
/// * `Priority::Low` → `1` (lowest)
///
/// # Value Mapping
/// The mapping ensures that standard numeric comparison operators work
/// correctly: `3 > 2 > 1` matches `High > Medium > Low`
///
/// # Example
/// ```
/// let high = Priority::High;
/// let medium = Priority::Medium;
/// let low = Priority::Low;
///
/// assert(priority_to_value(high) == 3);
/// assert(priority_to_value(medium) == 2);
/// assert(priority_to_value(low) == 1);
///
/// // Use for sorting
/// if priority_to_value(high) > priority_to_value(medium) {
///     println("High priority rules processed first");
/// }
/// ```
///
/// # Use Cases
/// - Sorting detection rules by priority
/// - Numeric priority comparison
/// - Priority-based scheduling
/// - Queue ordering
fun priority_to_value(priority: Priority) -> i32 {
    match priority {
        Priority::High => 3,
        Priority::Medium => 2,
        Priority::Low => 1,
    }
}

/// Compares two priorities and determines if the first has higher priority.
///
/// Uses `priority_to_value()` internally to convert both priorities to
/// numeric values and compares them. Returns true if the first priority
/// is strictly higher than the second.
///
/// # Arguments
/// * `p1` - First priority to compare
/// * `p2` - Second priority to compare
///
/// # Returns
/// * `true` if `p1` has higher priority than `p2`
/// * `false` if `p1` has equal or lower priority than `p2`
///
/// # Priority Ordering
/// `High > Medium > Low`
///
/// # Example
/// ```
/// let high = Priority::High;
/// let medium = Priority::Medium;
/// let low = Priority::Low;
///
/// // High vs Medium
/// assert(is_higher_priority(high, medium) == true);
/// assert(is_higher_priority(medium, high) == false);
///
/// // High vs Low
/// assert(is_higher_priority(high, low) == true);
/// assert(is_higher_priority(low, high) == false);
///
/// // Medium vs Low
/// assert(is_higher_priority(medium, low) == true);
/// assert(is_higher_priority(low, medium) == false);
///
/// // Equal priorities
/// assert(is_higher_priority(high, Priority::High) == false);
/// ```
///
/// # Use Cases
/// - Rule execution ordering
/// - Priority queue management
/// - Conflict resolution (which rule to apply first)
/// - Scheduler decision making
///
/// # Implementation Note
/// Uses value comparison rather than direct enum comparison for clarity
/// and maintainability. If priority values change, only `priority_to_value()`
/// needs updating.
fun is_higher_priority(p1: Priority, p2: Priority) -> bool {
    let v1 = priority_to_value(p1);
    let v2 = priority_to_value(p2);
    v1 > v2
}

// ============================================================================
// TESTS - Process Struct (All tests should PASS after REFACTOR)
// ============================================================================

/// Test basic Process creation and field access.
/// Verifies that struct fields are correctly set and accessible.
#[test]
fun test_process_creation() {
    // Create a valid process with typical values
    let proc = new_process(
        1234,
        "test_process",
        "/usr/bin/test",
        45.5,
        256,
        ProcessStatus::Running
    );

    // Verify fields are set correctly
    assert(proc.pid == 1234, "Process PID should be 1234");
    assert(proc.name == "test_process", "Process name should be 'test_process'");
    assert(proc.cmdline == "/usr/bin/test", "Process cmdline should be '/usr/bin/test'");
    assert(proc.cpu_usage == 45.5, "Process CPU usage should be 45.5");
    assert(proc.memory_mb == 256, "Process memory should be 256 MB");
    // Note: Can't easily test enum equality yet, skip for now
}

/// Test validation accepts processes with positive PIDs.
/// Valid PIDs should pass validation.
#[test]
fun test_process_validation_positive_pid() {
    // Create process with valid positive PID
    let valid_proc = new_process(
        1234,
        "valid",
        "/bin/valid",
        0.0,
        100,
        ProcessStatus::Running
    );

    assert(is_valid_process(valid_proc), "Process with positive PID should be valid");
}

/// Test validation rejects processes with negative PIDs.
/// PIDs must be positive (> 0), so negative values should fail.
#[test]
fun test_process_validation_negative_pid() {
    // Create process with invalid negative PID
    let invalid_proc = new_process(
        -1,
        "invalid",
        "/bin/invalid",
        0.0,
        100,
        ProcessStatus::Running
    );

    assert(!is_valid_process(invalid_proc), "Process with negative PID should be invalid");
}

/// Test validation rejects processes with CPU usage > 100%.
/// CPU usage must be in range [0.0, 100.0].
#[test]
fun test_process_validation_cpu_range() {
    // Create process with CPU usage out of range (> 100%)
    let invalid_cpu = new_process(
        1234,
        "cpu_hog",
        "/bin/hog",
        150.0,  // Invalid: > 100.0
        100,
        ProcessStatus::Running
    );

    assert(!is_valid_process(invalid_cpu), "Process with CPU > 100% should be invalid");
}

/// Test validation rejects processes with negative memory.
/// Memory usage must be non-negative (>= 0).
#[test]
fun test_process_validation_negative_memory() {
    // Create process with invalid negative memory
    let invalid_mem = new_process(
        1234,
        "test",
        "/bin/test",
        50.0,
        -100,  // Invalid: negative memory
        ProcessStatus::Running
    );

    assert(!is_valid_process(invalid_mem), "Process with negative memory should be invalid");
}

/// Test format_process() returns non-empty string.
/// Formatted output is required for logging and display.
#[test]
fun test_process_format() {
    // Create a process for formatting
    let proc = new_process(
        9999,
        "format_test",
        "/usr/bin/format_test --arg",
        75.5,
        512,
        ProcessStatus::Running
    );

    // Format should include key information
    let formatted = format_process(proc);

    assert(formatted != "", "Formatted process should not be empty");
}

/// Test edge case: Process with 0% CPU usage.
/// Zero CPU is valid (idle processes).
#[test]
fun test_process_zero_cpu() {
    // Process with zero CPU usage should be valid (idle/sleeping)
    let proc = new_process(
        1234,
        "idle",
        "/bin/idle",
        0.0,
        100,
        ProcessStatus::Sleeping
    );

    assert(proc.cpu_usage == 0.0, "Zero CPU usage should be allowed");
}

/// Test edge case: Process with 100% CPU usage.
/// Maximum CPU usage is valid (busy processes).
#[test]
fun test_process_max_cpu() {
    // Process with 100% CPU usage should be valid (fully utilized)
    let proc = new_process(
        1234,
        "busy",
        "/bin/busy",
        100.0,
        100,
        ProcessStatus::Running
    );

    assert(proc.cpu_usage == 100.0, "100% CPU usage should be allowed");
}

/// Test edge case: Process with 0 MB memory usage.
/// Zero memory is valid (kernel threads have no userspace memory).
#[test]
fun test_process_zero_memory() {
    // Process with zero memory should be valid (e.g., kthreadd)
    let proc = new_process(
        2,
        "kthreadd",
        "",
        0.0,
        0,
        ProcessStatus::Running
    );

    assert(proc.memory_mb == 0, "Zero memory should be allowed");
}

// ============================================================================
// TESTS - Priority Enum (All tests should PASS after REFACTOR)
// ============================================================================

/// Test priority_to_string() correctly converts High variant.
/// Verifies string representation for logging and display.
#[test]
fun test_priority_high_to_string() {
    let high = Priority::High;
    let result = priority_to_string(high);
    assert(result == "high", "Priority::High should convert to 'high'");
}

/// Test priority_to_string() correctly converts Medium variant.
/// Verifies string representation for configuration output.
#[test]
fun test_priority_medium_to_string() {
    let medium = Priority::Medium;
    let result = priority_to_string(medium);
    assert(result == "medium", "Priority::Medium should convert to 'medium'");
}

/// Test priority_to_string() correctly converts Low variant.
/// Verifies string representation for user-facing displays.
#[test]
fun test_priority_low_to_string() {
    let low = Priority::Low;
    let result = priority_to_string(low);
    assert(result == "low", "Priority::Low should convert to 'low'");
}

/// Test priority_to_value() assigns correct numeric values for all variants.
/// Verifies the value mapping: High=3, Medium=2, Low=1.
/// Critical for sorting and comparison operations.
#[test]
fun test_priority_to_value() {
    let high = Priority::High;
    let medium = Priority::Medium;
    let low = Priority::Low;

    assert(priority_to_value(high) == 3, "High priority should have value 3");
    assert(priority_to_value(medium) == 2, "Medium priority should have value 2");
    assert(priority_to_value(low) == 1, "Low priority should have value 1");
}

/// Test is_higher_priority() correctly compares High vs Medium.
/// Verifies bidirectional comparison: High > Medium and !(Medium > High).
#[test]
fun test_priority_high_vs_medium() {
    let high = Priority::High;
    let medium = Priority::Medium;

    assert(is_higher_priority(high, medium), "High should be higher than Medium");
    assert(!is_higher_priority(medium, high), "Medium should not be higher than High");
}

/// Test is_higher_priority() correctly compares High vs Low.
/// Verifies maximum vs minimum priority comparison.
#[test]
fun test_priority_high_vs_low() {
    let high = Priority::High;
    let low = Priority::Low;

    assert(is_higher_priority(high, low), "High should be higher than Low");
    assert(!is_higher_priority(low, high), "Low should not be higher than High");
}

/// Test is_higher_priority() correctly compares Medium vs Low.
/// Verifies middle tier priority comparison.
#[test]
fun test_priority_medium_vs_low() {
    let medium = Priority::Medium;
    let low = Priority::Low;

    assert(is_higher_priority(medium, low), "Medium should be higher than Low");
    assert(!is_higher_priority(low, medium), "Low should not be higher than Medium");
}

/// Test is_higher_priority() with equal priorities returns false.
/// Verifies that same priority levels are not considered "higher".
/// Important for queue fairness and rule ordering.
#[test]
fun test_priority_equal() {
    let high1 = Priority::High;
    let high2 = Priority::High;

    assert(!is_higher_priority(high1, high2), "Equal priorities should return false");
}

// ============================================================================
// MAIN
// ============================================================================

/// Main entry point for Reaper process watcher.
/// Currently in TDD development phase, demonstrating extreme TDD methodology.
fun main() {
    println("========================================");
    println("Reaper v0.2.0 - Rogue Process Watcher");
    println("Pure Ruchy v3.155.0 - TDD Implementation");
    println("========================================");
    println("");
    println("Status: REAPER-106 REFACTOR PHASE");
    println("Current: Improving Priority enum documentation");
    println("");
    println("Completed Cycles:");
    println("  ✅ Process struct (full RED-GREEN-REFACTOR)");
    println("  ✅ Priority enum (RED-GREEN, REFACTOR in progress)");
    println("");
    println("Current TDD Cycle (Priority enum):");
    println("  [✓] RED: Write failing tests");
    println("  [✓] GREEN: Make tests pass");
    println("  [X] REFACTOR: Improve code quality");
    println("");
    println("Improvements:");
    println("  - Comprehensive Priority enum documentation");
    println("  - Full doc comments for all helper functions");
    println("  - Usage examples and use cases");
    println("  - Enhanced test documentation");
    println("");
    println("Tests: 17 tests total (all passing)");
    println("Next: Validate quality and complete cycle");
    println("========================================");
}
