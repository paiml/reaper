// Reaper - Rogue Process Watcher
// Pure Ruchy v3.155.0 Implementation
// Single-file architecture with extreme TDD
//
// TICKET: REAPER-106 (RED phase) - Priority enum tests
// Status: Writing failing tests for Priority enum (RED phase of TDD)
//
// This tool automatically detects and terminates rogue processes that consume
// excessive system resources. Based on real production incident (2025-10-31)
// where 17 rogue processes required manual intervention.

// ============================================================================
// DATA STRUCTURES
// ============================================================================

/// Priority represents the urgency level of a detection rule.
/// Used to prioritize which rogue processes to terminate first.
enum Priority {
    High,
    Medium,
    Low,
}

/// ProcessStatus represents the current execution state of a process.
/// Maps to Linux process states from /proc/[pid]/stat.
///
/// # Variants
/// * `Running` - Process is actively executing on CPU (state 'R')
/// * `Sleeping` - Process is waiting for I/O or event (state 'S')
/// * `Stopped` - Process has been stopped by signal (state 'T')
/// * `Zombie` - Process terminated but not yet reaped by parent (state 'Z')
enum ProcessStatus {
    Running,
    Sleeping,
    Stopped,
    Zombie,
}

/// Process represents a snapshot of a single process at a point in time.
/// Contains all information needed for detection and termination decisions.
///
/// # Fields
/// * `pid` - Process ID (must be positive, typically 1-32768)
/// * `name` - Process name from /proc/[pid]/comm (max 16 chars in Linux)
/// * `cmdline` - Full command line with arguments from /proc/[pid]/cmdline
/// * `cpu_usage` - CPU usage percentage (0.0-100.0)
/// * `memory_mb` - Memory usage in megabytes (resident set size)
/// * `status` - Current process execution state
///
/// # Validation
/// Use `is_valid_process()` to validate field values after creation.
///
/// # Example
/// ```
/// let proc = new_process(
///     1234,
///     "my_process",
///     "/usr/bin/my_process --flag",
///     45.5,
///     256,
///     ProcessStatus::Running
/// );
/// assert(is_valid_process(proc));
/// ```
struct Process {
    pid: i32,
    name: String,
    cmdline: String,
    cpu_usage: f64,
    memory_mb: i64,
    status: ProcessStatus,
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/// Creates a new Process instance with the given values.
///
/// This constructor does NOT validate inputs. Use `is_valid_process()`
/// after creation to ensure all field values are within valid ranges.
///
/// # Arguments
/// * `pid` - Process ID (should be positive)
/// * `name` - Process name (from /proc/[pid]/comm)
/// * `cmdline` - Full command line (from /proc/[pid]/cmdline)
/// * `cpu_usage` - CPU usage percentage (should be 0.0-100.0)
/// * `memory_mb` - Memory usage in MB (should be non-negative)
/// * `status` - Current process state
///
/// # Returns
/// A new Process instance with the specified values
///
/// # Example
/// ```
/// let proc = new_process(
///     1234,
///     "test",
///     "/usr/bin/test",
///     45.5,
///     256,
///     ProcessStatus::Running
/// );
/// ```
fun new_process(pid: i32, name: String, cmdline: String, cpu_usage: f64, memory_mb: i64, status: ProcessStatus) -> Process {
    Process {
        pid: pid,
        name: name,
        cmdline: cmdline,
        cpu_usage: cpu_usage,
        memory_mb: memory_mb,
        status: status,
    }
}

/// Validates that a Process has valid field values.
///
/// Checks three critical invariants:
/// 1. PID must be positive (> 0)
/// 2. CPU usage must be in range [0.0, 100.0]
/// 3. Memory usage must be non-negative (>= 0)
///
/// # Arguments
/// * `proc` - The Process to validate
///
/// # Returns
/// * `true` if all validations pass
/// * `false` if any validation fails
///
/// # Validation Rules
/// * PID: Must be > 0 (Linux PIDs start at 1, max typically 32768)
/// * CPU: Must be >= 0.0 and <= 100.0 (percentage)
/// * Memory: Must be >= 0 (kernel threads can have 0 memory)
///
/// # Example
/// ```
/// let valid = new_process(1234, "test", "/bin/test", 50.0, 256, ProcessStatus::Running);
/// assert(is_valid_process(valid));
///
/// let invalid = new_process(-1, "bad", "/bin/bad", 50.0, 256, ProcessStatus::Running);
/// assert(!is_valid_process(invalid));
/// ```
fun is_valid_process(proc: Process) -> bool {
    // Validate PID (must be positive)
    // Linux PIDs start at 1, with 0 reserved for scheduler
    if proc.pid <= 0 {
        return false;
    }

    // Validate CPU usage (must be in range [0.0, 100.0])
    // Note: On multi-core systems, individual process usage per core
    // is still capped at 100% in our model
    if proc.cpu_usage < 0.0 || proc.cpu_usage > 100.0 {
        return false;
    }

    // Validate memory (must be non-negative)
    // Kernel threads legitimately have 0 memory usage
    if proc.memory_mb < 0 {
        return false;
    }

    // All validations passed
    true
}

/// Formats a Process as a human-readable string for display.
///
/// Creates a compact string representation including the most important
/// fields for process identification and resource usage monitoring.
///
/// # Arguments
/// * `proc` - The Process to format
///
/// # Returns
/// A formatted string in the format:
/// `"Process[PID=1234, name='test', CPU=45.5%, MEM=256MB]"`
///
/// # Format Details
/// * PID displayed as integer
/// * Name shown in single quotes for clarity
/// * CPU usage with % suffix
/// * Memory with MB suffix
///
/// # Example
/// ```
/// let proc = new_process(9999, "example", "/usr/bin/example", 75.5, 512, ProcessStatus::Running);
/// let output = format_process(proc);
/// // output == "Process[PID=9999, name='example', CPU=75.5%, MEM=512MB]"
/// ```
fun format_process(proc: Process) -> String {
    // Build formatted string with all key process information
    // Format: Process[PID=X, name='Y', CPU=Z%, MEM=WMB]
    let formatted = "Process[PID=";
    formatted = formatted + proc.pid.to_string();
    formatted = formatted + ", name='";
    formatted = formatted + proc.name;
    formatted = formatted + "', CPU=";
    formatted = formatted + proc.cpu_usage.to_string();
    formatted = formatted + "%, MEM=";
    formatted = formatted + proc.memory_mb.to_string();
    formatted = formatted + "MB]";
    formatted
}

/// Converts a Priority to its string representation.
/// Returns the priority name in lowercase.
fun priority_to_string(priority: Priority) -> String {
    // TODO: Implement in GREEN phase
    // This should fail tests in RED phase
    ""  // Placeholder - returns empty string for RED phase
}

/// Converts a Priority to its numeric value for sorting.
/// Higher priority = higher numeric value.
/// Returns: High=3, Medium=2, Low=1
fun priority_to_value(priority: Priority) -> i32 {
    // TODO: Implement in GREEN phase
    // This should fail tests in RED phase
    0  // Placeholder - always returns 0 for RED phase
}

/// Compares two priorities and returns true if first is higher priority.
/// High > Medium > Low
fun is_higher_priority(p1: Priority, p2: Priority) -> bool {
    // TODO: Implement in GREEN phase
    // This should fail tests in RED phase
    false  // Placeholder - always returns false for RED phase
}

// ============================================================================
// TESTS - Process Struct (All tests should PASS after REFACTOR)
// ============================================================================

/// Test basic Process creation and field access.
/// Verifies that struct fields are correctly set and accessible.
#[test]
fun test_process_creation() {
    // Create a valid process with typical values
    let proc = new_process(
        1234,
        "test_process",
        "/usr/bin/test",
        45.5,
        256,
        ProcessStatus::Running
    );

    // Verify fields are set correctly
    assert(proc.pid == 1234, "Process PID should be 1234");
    assert(proc.name == "test_process", "Process name should be 'test_process'");
    assert(proc.cmdline == "/usr/bin/test", "Process cmdline should be '/usr/bin/test'");
    assert(proc.cpu_usage == 45.5, "Process CPU usage should be 45.5");
    assert(proc.memory_mb == 256, "Process memory should be 256 MB");
    // Note: Can't easily test enum equality yet, skip for now
}

/// Test validation accepts processes with positive PIDs.
/// Valid PIDs should pass validation.
#[test]
fun test_process_validation_positive_pid() {
    // Create process with valid positive PID
    let valid_proc = new_process(
        1234,
        "valid",
        "/bin/valid",
        0.0,
        100,
        ProcessStatus::Running
    );

    assert(is_valid_process(valid_proc), "Process with positive PID should be valid");
}

/// Test validation rejects processes with negative PIDs.
/// PIDs must be positive (> 0), so negative values should fail.
#[test]
fun test_process_validation_negative_pid() {
    // Create process with invalid negative PID
    let invalid_proc = new_process(
        -1,
        "invalid",
        "/bin/invalid",
        0.0,
        100,
        ProcessStatus::Running
    );

    assert(!is_valid_process(invalid_proc), "Process with negative PID should be invalid");
}

/// Test validation rejects processes with CPU usage > 100%.
/// CPU usage must be in range [0.0, 100.0].
#[test]
fun test_process_validation_cpu_range() {
    // Create process with CPU usage out of range (> 100%)
    let invalid_cpu = new_process(
        1234,
        "cpu_hog",
        "/bin/hog",
        150.0,  // Invalid: > 100.0
        100,
        ProcessStatus::Running
    );

    assert(!is_valid_process(invalid_cpu), "Process with CPU > 100% should be invalid");
}

/// Test validation rejects processes with negative memory.
/// Memory usage must be non-negative (>= 0).
#[test]
fun test_process_validation_negative_memory() {
    // Create process with invalid negative memory
    let invalid_mem = new_process(
        1234,
        "test",
        "/bin/test",
        50.0,
        -100,  // Invalid: negative memory
        ProcessStatus::Running
    );

    assert(!is_valid_process(invalid_mem), "Process with negative memory should be invalid");
}

/// Test format_process() returns non-empty string.
/// Formatted output is required for logging and display.
#[test]
fun test_process_format() {
    // Create a process for formatting
    let proc = new_process(
        9999,
        "format_test",
        "/usr/bin/format_test --arg",
        75.5,
        512,
        ProcessStatus::Running
    );

    // Format should include key information
    let formatted = format_process(proc);

    assert(formatted != "", "Formatted process should not be empty");
}

/// Test edge case: Process with 0% CPU usage.
/// Zero CPU is valid (idle processes).
#[test]
fun test_process_zero_cpu() {
    // Process with zero CPU usage should be valid (idle/sleeping)
    let proc = new_process(
        1234,
        "idle",
        "/bin/idle",
        0.0,
        100,
        ProcessStatus::Sleeping
    );

    assert(proc.cpu_usage == 0.0, "Zero CPU usage should be allowed");
}

/// Test edge case: Process with 100% CPU usage.
/// Maximum CPU usage is valid (busy processes).
#[test]
fun test_process_max_cpu() {
    // Process with 100% CPU usage should be valid (fully utilized)
    let proc = new_process(
        1234,
        "busy",
        "/bin/busy",
        100.0,
        100,
        ProcessStatus::Running
    );

    assert(proc.cpu_usage == 100.0, "100% CPU usage should be allowed");
}

/// Test edge case: Process with 0 MB memory usage.
/// Zero memory is valid (kernel threads have no userspace memory).
#[test]
fun test_process_zero_memory() {
    // Process with zero memory should be valid (e.g., kthreadd)
    let proc = new_process(
        2,
        "kthreadd",
        "",
        0.0,
        0,
        ProcessStatus::Running
    );

    assert(proc.memory_mb == 0, "Zero memory should be allowed");
}

// ============================================================================
// TESTS - Priority Enum (expect these to FAIL in RED phase)
// ============================================================================

/// Test priority_to_string() converts High to "high"
#[test]
fun test_priority_high_to_string() {
    let high = Priority::High;
    let result = priority_to_string(high);
    // This will FAIL in RED phase (returns empty string)
    assert(result == "high", "Priority::High should convert to 'high'");
}

/// Test priority_to_string() converts Medium to "medium"
#[test]
fun test_priority_medium_to_string() {
    let medium = Priority::Medium;
    let result = priority_to_string(medium);
    // This will FAIL in RED phase
    assert(result == "medium", "Priority::Medium should convert to 'medium'");
}

/// Test priority_to_string() converts Low to "low"
#[test]
fun test_priority_low_to_string() {
    let low = Priority::Low;
    let result = priority_to_string(low);
    // This will FAIL in RED phase
    assert(result == "low", "Priority::Low should convert to 'low'");
}

/// Test priority_to_value() assigns correct numeric values
#[test]
fun test_priority_to_value() {
    let high = Priority::High;
    let medium = Priority::Medium;
    let low = Priority::Low;

    // This will FAIL in RED phase (all return 0)
    assert(priority_to_value(high) == 3, "High priority should have value 3");
    assert(priority_to_value(medium) == 2, "Medium priority should have value 2");
    assert(priority_to_value(low) == 1, "Low priority should have value 1");
}

/// Test is_higher_priority() correctly compares High vs Medium
#[test]
fun test_priority_high_vs_medium() {
    let high = Priority::High;
    let medium = Priority::Medium;

    // This will FAIL in RED phase (always returns false)
    assert(is_higher_priority(high, medium), "High should be higher than Medium");
    assert(!is_higher_priority(medium, high), "Medium should not be higher than High");
}

/// Test is_higher_priority() correctly compares High vs Low
#[test]
fun test_priority_high_vs_low() {
    let high = Priority::High;
    let low = Priority::Low;

    // This will FAIL in RED phase
    assert(is_higher_priority(high, low), "High should be higher than Low");
    assert(!is_higher_priority(low, high), "Low should not be higher than High");
}

/// Test is_higher_priority() correctly compares Medium vs Low
#[test]
fun test_priority_medium_vs_low() {
    let medium = Priority::Medium;
    let low = Priority::Low;

    // This will FAIL in RED phase
    assert(is_higher_priority(medium, low), "Medium should be higher than Low");
    assert(!is_higher_priority(low, medium), "Low should not be higher than Medium");
}

/// Test is_higher_priority() with equal priorities returns false
#[test]
fun test_priority_equal() {
    let high1 = Priority::High;
    let high2 = Priority::High;

    // This will FAIL in RED phase
    assert(!is_higher_priority(high1, high2), "Equal priorities should return false");
}

// ============================================================================
// MAIN
// ============================================================================

/// Main entry point for Reaper process watcher.
/// Currently in TDD development phase, demonstrating extreme TDD methodology.
fun main() {
    println("========================================");
    println("Reaper v0.2.0 - Rogue Process Watcher");
    println("Pure Ruchy v3.155.0 - TDD Implementation");
    println("========================================");
    println("");
    println("Status: REAPER-106 RED PHASE");
    println("Current: Writing tests for Priority enum");
    println("");
    println("Completed:");
    println("  âœ… Process struct (full RED-GREEN-REFACTOR cycle)");
    println("");
    println("Current TDD Cycle (Priority enum):");
    println("  [X] RED: Write failing tests");
    println("  [ ] GREEN: Make tests pass");
    println("  [ ] REFACTOR: Improve code quality");
    println("");
    println("Tests: 8 Priority enum tests (expect FAILURES)");
    println("Next: Run 'ruchy test' - expect FAILURES (RED phase)");
    println("========================================");
}
