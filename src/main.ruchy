// Reaper - Rogue Process Watcher
// Pure Ruchy v3.155.0 Implementation
// Single-file architecture with extreme TDD
//
// TICKET: REAPER-108 (RED phase) - DetectionRule struct tests
// Status: Writing failing tests for DetectionRule (RED phase of TDD)
//
// This tool automatically detects and terminates rogue processes that consume
// excessive system resources. Based on real production incident (2025-10-31)
// where 17 rogue processes required manual intervention.

// ============================================================================
// DATA STRUCTURES
// ============================================================================

/// Priority represents the urgency level of a detection rule.
///
/// Priorities determine the order in which rogue processes are terminated.
/// Higher priority rules are checked and enforced before lower priority rules.
/// This ensures critical resource protection is prioritized.
///
/// # Variants
/// * `High` - Critical priority (value=3). Processes matching high-priority
///   rules are terminated immediately without grace period. Use for severe
///   resource exhaustion that threatens system stability.
///
/// * `Medium` - Normal priority (value=2). Standard detection rules with
///   normal termination flow (SIGTERM, then SIGKILL after grace period).
///   Use for typical rogue process detection.
///
/// * `Low` - Advisory priority (value=1). Low-priority rules may only log
///   violations rather than terminate. Use for monitoring and alerting
///   without automatic termination.
///
/// # Ordering
/// Priority ordering: High > Medium > Low
///
/// # Usage
/// ```
/// let critical_rule_priority = Priority::High;
/// let standard_rule_priority = Priority::Medium;
///
/// // Compare priorities
/// if is_higher_priority(critical_rule_priority, standard_rule_priority) {
///     println("Critical rule takes precedence");
/// }
///
/// // Convert to string for logging
/// println("Priority: {}", priority_to_string(critical_rule_priority));
/// // Output: "Priority: high"
/// ```
///
/// # Example: Rule Prioritization
/// ```
/// // High priority: Immediate threat to system
/// let memory_bomb = DetectionRule {
///     priority: Priority::High,
///     max_memory_mb: 8192,  // 8GB limit
///     ...
/// };
///
/// // Medium priority: Normal resource control
/// let cpu_hog = DetectionRule {
///     priority: Priority::Medium,
///     max_cpu_percent: 90.0,
///     ...
/// };
///
/// // Low priority: Monitoring only
/// let suspicious_pattern = DetectionRule {
///     priority: Priority::Low,
///     name_pattern: "suspicious.*",
///     ...
/// };
/// ```
enum Priority {
    High,
    Medium,
    Low,
}

/// ProcessStatus represents the current execution state of a process.
/// Maps to Linux process states from /proc/[pid]/stat.
///
/// # Variants
/// * `Running` - Process is actively executing on CPU (state 'R')
/// * `Sleeping` - Process is waiting for I/O or event (state 'S')
/// * `Stopped` - Process has been stopped by signal (state 'T')
/// * `Zombie` - Process terminated but not yet reaped by parent (state 'Z')
enum ProcessStatus {
    Running,
    Sleeping,
    Stopped,
    Zombie,
}

/// Process represents a snapshot of a single process at a point in time.
/// Contains all information needed for detection and termination decisions.
///
/// # Fields
/// * `pid` - Process ID (must be positive, typically 1-32768)
/// * `name` - Process name from /proc/[pid]/comm (max 16 chars in Linux)
/// * `cmdline` - Full command line with arguments from /proc/[pid]/cmdline
/// * `cpu_usage` - CPU usage percentage (0.0-100.0)
/// * `memory_mb` - Memory usage in megabytes (resident set size)
/// * `status` - Current process execution state
///
/// # Validation
/// Use `is_valid_process()` to validate field values after creation.
///
/// # Example
/// ```
/// let proc = new_process(
///     1234,
///     "my_process",
///     "/usr/bin/my_process --flag",
///     45.5,
///     256,
///     ProcessStatus::Running
/// );
/// assert(is_valid_process(proc));
/// ```
struct Process {
    pid: i32,
    name: String,
    cmdline: String,
    cpu_usage: f64,
    memory_mb: i64,
    status: ProcessStatus,
}

/// DetectionRule defines criteria for identifying rogue processes.
///
/// A detection rule combines resource thresholds (CPU, memory) with pattern
/// matching (process name, command line) to identify processes that should be
/// terminated. Rules can be prioritized and enabled/disabled dynamically.
///
/// # Fields
/// * `name` - Human-readable rule name (e.g., "High CPU Hog")
/// * `priority` - Rule priority (High, Medium, Low)
/// * `max_cpu_percent` - CPU threshold in % (0.0-100.0, 0.0 = disabled)
/// * `max_memory_mb` - Memory threshold in MB (>= 0, 0 = disabled)
/// * `name_pattern` - Process name pattern to match (empty = any)
/// * `cmdline_pattern` - Command line pattern to match (empty = any)
/// * `enabled` - Whether this rule is active
///
/// # Threshold Semantics
/// * **Zero values disable that threshold** (0.0 for CPU, 0 for memory)
/// * Multiple thresholds use AND logic (all must match)
/// * Disabled rules never match any process
///
/// # Pattern Matching
/// * Patterns use case-sensitive substring matching
/// * Empty patterns match any value
/// * Both name and cmdline patterns must match if specified
///
/// # Example
/// ```
/// // Rule to catch processes using > 80% CPU with "python" in name
/// let rule = new_detection_rule(
///     "Python CPU Hog",
///     Priority::High,
///     80.0,  // CPU threshold
///     0,     // No memory limit
///     "python",
///     "",
///     true
/// );
///
/// // Rule to catch any process using > 4GB memory
/// let mem_rule = new_detection_rule(
///     "Memory Hog",
///     Priority::Medium,
///     0.0,   // No CPU limit
///     4096,  // 4GB memory threshold
///     "",
///     "",
///     true
/// );
/// ```
struct DetectionRule {
    name: String,
    priority: Priority,
    max_cpu_percent: f64,
    max_memory_mb: i64,
    name_pattern: String,
    cmdline_pattern: String,
    enabled: bool,
}

/// Config holds the application configuration for Reaper.
///
/// Contains all runtime settings including scan intervals, detection rules,
/// operational modes (dry-run), logging configuration, and termination behavior.
///
/// # Fields
/// * `check_interval_secs` - How often to scan processes (seconds, default: 60)
/// * `rules` - Array of DetectionRule instances to apply
/// * `dry_run` - If true, log detections but don't terminate processes
/// * `log_file` - Path to log file (default: "/var/log/reaper.log")
/// * `grace_period_secs` - Seconds to wait between SIGTERM and SIGKILL (default: 5)
///
/// # Validation Rules
/// * `check_interval_secs` must be > 0 (typically 10-300)
/// * `rules` array can be empty (no rules = no detections)
/// * `log_file` must be non-empty
/// * `grace_period_secs` must be >= 0 (0 = SIGKILL immediately)
///
/// # Example
/// ```
/// let config = new_config(
///     60,      // Check every minute
///     [],      // No rules yet
///     false,   // Real mode (not dry-run)
///     "/var/log/reaper.log",
///     5        // 5 second grace period
/// );
/// ```
struct Config {
    check_interval_secs: i64,
    rules: [DetectionRule],
    dry_run: bool,
    log_file: String,
    grace_period_secs: i64,
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/// Creates a new Process instance with the given values.
///
/// This constructor does NOT validate inputs. Use `is_valid_process()`
/// after creation to ensure all field values are within valid ranges.
///
/// # Arguments
/// * `pid` - Process ID (should be positive)
/// * `name` - Process name (from /proc/[pid]/comm)
/// * `cmdline` - Full command line (from /proc/[pid]/cmdline)
/// * `cpu_usage` - CPU usage percentage (should be 0.0-100.0)
/// * `memory_mb` - Memory usage in MB (should be non-negative)
/// * `status` - Current process state
///
/// # Returns
/// A new Process instance with the specified values
///
/// # Example
/// ```
/// let proc = new_process(
///     1234,
///     "test",
///     "/usr/bin/test",
///     45.5,
///     256,
///     ProcessStatus::Running
/// );
/// ```
fun new_process(pid: i32, name: String, cmdline: String, cpu_usage: f64, memory_mb: i64, status: ProcessStatus) -> Process {
    Process {
        pid: pid,
        name: name,
        cmdline: cmdline,
        cpu_usage: cpu_usage,
        memory_mb: memory_mb,
        status: status,
    }
}

/// Validates that a Process has valid field values.
///
/// Checks three critical invariants:
/// 1. PID must be positive (> 0)
/// 2. CPU usage must be in range [0.0, 100.0]
/// 3. Memory usage must be non-negative (>= 0)
///
/// # Arguments
/// * `proc` - The Process to validate
///
/// # Returns
/// * `true` if all validations pass
/// * `false` if any validation fails
///
/// # Validation Rules
/// * PID: Must be > 0 (Linux PIDs start at 1, max typically 32768)
/// * CPU: Must be >= 0.0 and <= 100.0 (percentage)
/// * Memory: Must be >= 0 (kernel threads can have 0 memory)
///
/// # Example
/// ```
/// let valid = new_process(1234, "test", "/bin/test", 50.0, 256, ProcessStatus::Running);
/// assert(is_valid_process(valid));
///
/// let invalid = new_process(-1, "bad", "/bin/bad", 50.0, 256, ProcessStatus::Running);
/// assert(!is_valid_process(invalid));
/// ```
fun is_valid_process(proc: Process) -> bool {
    // Validate PID (must be positive)
    // Linux PIDs start at 1, with 0 reserved for scheduler
    if proc.pid <= 0 {
        return false;
    }

    // Validate CPU usage (must be in range [0.0, 100.0])
    // Note: On multi-core systems, individual process usage per core
    // is still capped at 100% in our model
    if proc.cpu_usage < 0.0 || proc.cpu_usage > 100.0 {
        return false;
    }

    // Validate memory (must be non-negative)
    // Kernel threads legitimately have 0 memory usage
    if proc.memory_mb < 0 {
        return false;
    }

    // All validations passed
    true
}

/// Formats a Process as a human-readable string for display.
///
/// Creates a compact string representation including the most important
/// fields for process identification and resource usage monitoring.
///
/// # Arguments
/// * `proc` - The Process to format
///
/// # Returns
/// A formatted string in the format:
/// `"Process[PID=1234, name='test', CPU=45.5%, MEM=256MB]"`
///
/// # Format Details
/// * PID displayed as integer
/// * Name shown in single quotes for clarity
/// * CPU usage with % suffix
/// * Memory with MB suffix
///
/// # Example
/// ```
/// let proc = new_process(9999, "example", "/usr/bin/example", 75.5, 512, ProcessStatus::Running);
/// let output = format_process(proc);
/// // output == "Process[PID=9999, name='example', CPU=75.5%, MEM=512MB]"
/// ```
fun format_process(proc: Process) -> String {
    // Build formatted string with all key process information
    // Format: Process[PID=X, name='Y', CPU=Z%, MEM=WMB]
    let formatted = "Process[PID=";
    formatted = formatted + proc.pid.to_string();
    formatted = formatted + ", name='";
    formatted = formatted + proc.name;
    formatted = formatted + "', CPU=";
    formatted = formatted + proc.cpu_usage.to_string();
    formatted = formatted + "%, MEM=";
    formatted = formatted + proc.memory_mb.to_string();
    formatted = formatted + "MB]";
    formatted
}

/// Converts a Priority to its string representation.
///
/// Returns the priority name in lowercase, suitable for logging,
/// configuration files, and user display.
///
/// # Arguments
/// * `priority` - The Priority variant to convert
///
/// # Returns
/// A lowercase string representation:
/// * `Priority::High` → `"high"`
/// * `Priority::Medium` → `"medium"`
/// * `Priority::Low` → `"low"`
///
/// # Example
/// ```
/// let p = Priority::High;
/// let name = priority_to_string(p);
/// assert(name == "high");
///
/// // Use in logging
/// println("Rule priority: {}", priority_to_string(Priority::Medium));
/// // Output: "Rule priority: medium"
/// ```
///
/// # Use Cases
/// - Logging and audit trails
/// - Configuration file output
/// - User-facing displays
/// - API responses
fun priority_to_string(priority: Priority) -> String {
    match priority {
        Priority::High => "high",
        Priority::Medium => "medium",
        Priority::Low => "low",
    }
}

/// Converts a Priority to its numeric value for sorting and comparison.
///
/// Returns an integer value where higher numbers indicate higher priority.
/// This enables numeric comparison and sorting of priorities.
///
/// # Arguments
/// * `priority` - The Priority variant to convert
///
/// # Returns
/// An integer value representing priority level:
/// * `Priority::High` → `3` (highest)
/// * `Priority::Medium` → `2`
/// * `Priority::Low` → `1` (lowest)
///
/// # Value Mapping
/// The mapping ensures that standard numeric comparison operators work
/// correctly: `3 > 2 > 1` matches `High > Medium > Low`
///
/// # Example
/// ```
/// let high = Priority::High;
/// let medium = Priority::Medium;
/// let low = Priority::Low;
///
/// assert(priority_to_value(high) == 3);
/// assert(priority_to_value(medium) == 2);
/// assert(priority_to_value(low) == 1);
///
/// // Use for sorting
/// if priority_to_value(high) > priority_to_value(medium) {
///     println("High priority rules processed first");
/// }
/// ```
///
/// # Use Cases
/// - Sorting detection rules by priority
/// - Numeric priority comparison
/// - Priority-based scheduling
/// - Queue ordering
fun priority_to_value(priority: Priority) -> i32 {
    match priority {
        Priority::High => 3,
        Priority::Medium => 2,
        Priority::Low => 1,
    }
}

/// Compares two priorities and determines if the first has higher priority.
///
/// Uses `priority_to_value()` internally to convert both priorities to
/// numeric values and compares them. Returns true if the first priority
/// is strictly higher than the second.
///
/// # Arguments
/// * `p1` - First priority to compare
/// * `p2` - Second priority to compare
///
/// # Returns
/// * `true` if `p1` has higher priority than `p2`
/// * `false` if `p1` has equal or lower priority than `p2`
///
/// # Priority Ordering
/// `High > Medium > Low`
///
/// # Example
/// ```
/// let high = Priority::High;
/// let medium = Priority::Medium;
/// let low = Priority::Low;
///
/// // High vs Medium
/// assert(is_higher_priority(high, medium) == true);
/// assert(is_higher_priority(medium, high) == false);
///
/// // High vs Low
/// assert(is_higher_priority(high, low) == true);
/// assert(is_higher_priority(low, high) == false);
///
/// // Medium vs Low
/// assert(is_higher_priority(medium, low) == true);
/// assert(is_higher_priority(low, medium) == false);
///
/// // Equal priorities
/// assert(is_higher_priority(high, Priority::High) == false);
/// ```
///
/// # Use Cases
/// - Rule execution ordering
/// - Priority queue management
/// - Conflict resolution (which rule to apply first)
/// - Scheduler decision making
///
/// # Implementation Note
/// Uses value comparison rather than direct enum comparison for clarity
/// and maintainability. If priority values change, only `priority_to_value()`
/// needs updating.
fun is_higher_priority(p1: Priority, p2: Priority) -> bool {
    let v1 = priority_to_value(p1);
    let v2 = priority_to_value(p2);
    v1 > v2
}

/// Creates a new DetectionRule instance with the given values.
///
/// This constructor does NOT validate inputs. Use `is_valid_rule()` after
/// creation to ensure all field values are valid.
///
/// # Arguments
/// * `name` - Human-readable rule name
/// * `priority` - Rule priority (High, Medium, Low)
/// * `max_cpu` - CPU threshold % (0.0-100.0, 0.0 = disabled)
/// * `max_mem` - Memory threshold MB (>= 0, 0 = disabled)
/// * `name_pattern` - Process name pattern (empty = any)
/// * `cmdline_pattern` - Command line pattern (empty = any)
/// * `enabled` - Whether rule is active
///
/// # Returns
/// A DetectionRule instance with all fields set
///
/// # Example
/// ```
/// let rule = new_detection_rule(
///     "CPU Hog",
///     Priority::High,
///     80.0,
///     1024,
///     "python",
///     "",
///     true
/// );
/// assert(is_valid_rule(rule), "Rule should be valid");
/// ```
fun new_detection_rule(name: String, priority: Priority, max_cpu: f64, max_mem: i64, name_pattern: String, cmdline_pattern: String, enabled: bool) -> DetectionRule {
    DetectionRule {
        name: name,
        priority: priority,
        max_cpu_percent: max_cpu,
        max_memory_mb: max_mem,
        name_pattern: name_pattern,
        cmdline_pattern: cmdline_pattern,
        enabled: enabled,
    }
}

/// Validates that a DetectionRule has valid field values.
///
/// Checks that all rule fields contain valid values according to the
/// DetectionRule specification. This should be called after construction
/// to ensure rule integrity before use.
///
/// # Arguments
/// * `rule` - The DetectionRule to validate
///
/// # Returns
/// * `true` if all validations pass
/// * `false` if any validation fails
///
/// # Validation Rules
/// * **CPU threshold**: Must be in range [0.0, 100.0]
///   - 0.0 means CPU checking is disabled
///   - Values > 100.0 are invalid (even on multi-core systems)
/// * **Memory threshold**: Must be >= 0
///   - 0 means memory checking is disabled
///   - Negative values are invalid
/// * **Name**: Must be non-empty
///   - Empty names would make rules unidentifiable in logs
///
/// # Example
/// ```
/// // Valid rule
/// let valid = new_detection_rule("Test", Priority::High, 80.0, 1024, "", "", true);
/// assert(is_valid_rule(valid));
///
/// // Invalid rule (CPU > 100%)
/// let invalid = new_detection_rule("Bad", Priority::High, 150.0, 1024, "", "", true);
/// assert(!is_valid_rule(invalid));
///
/// // Valid rule with zero thresholds (disabled)
/// let pattern_only = new_detection_rule("PatternOnly", Priority::Low, 0.0, 0, "test", "", true);
/// assert(is_valid_rule(pattern_only));
/// ```
fun is_valid_rule(rule: DetectionRule) -> bool {
    // CPU threshold must be 0.0-100.0
    if rule.max_cpu_percent < 0.0 || rule.max_cpu_percent > 100.0 {
        return false;
    }

    // Memory threshold must be non-negative
    if rule.max_memory_mb < 0 {
        return false;
    }

    // Name must be non-empty
    if rule.name == "" {
        return false;
    }

    true
}

/// Checks if a process matches this detection rule.
///
/// Determines whether a process should be flagged as "rogue" according to
/// this rule's criteria. Uses AND logic - all enabled conditions must match.
///
/// # Arguments
/// * `rule` - The DetectionRule to apply
/// * `proc` - The Process to check
///
/// # Returns
/// * `true` if the process matches all enabled rule criteria
/// * `false` if:
///   - The rule is disabled
///   - Any enabled condition fails to match
///   - All thresholds are disabled (0/empty)
///
/// # Matching Logic
/// 1. **Disabled Check**: If `rule.enabled == false`, return false immediately
/// 2. **CPU Threshold**: If `max_cpu_percent > 0.0`, process CPU must EXCEED it
///    - Example: threshold 80.0 matches process with 80.1% CPU but not 80.0%
/// 3. **Memory Threshold**: If `max_memory_mb > 0`, process memory must EXCEED it
///    - Example: threshold 1024MB matches process with 1025MB but not 1024MB
/// 4. **Name Pattern**: If non-empty, process name must contain pattern
///    - Uses case-sensitive substring matching (contains)
/// 5. **Cmdline Pattern**: If non-empty, cmdline must contain pattern
///    - Uses case-sensitive substring matching (contains)
/// 6. **Result**: Returns true only if ALL enabled conditions match
///
/// # Zero/Empty Values
/// * Zero thresholds (0.0, 0) mean "disabled" - not checked
/// * Empty patterns ("") mean "match any" - not checked
/// * If ALL thresholds/patterns are disabled, rule matches everything (if enabled)
///
/// # Example
/// ```
/// // Rule: CPU > 80% with "python" in name
/// let rule = new_detection_rule("Python Hog", Priority::High, 80.0, 0, "python", "", true);
///
/// let proc1 = new_process(1, "python3", "/usr/bin/python3", 90.0, 512, ProcessStatus::Running);
/// assert(rule_matches_process(rule, proc1));  // Matches: 90% > 80% AND name contains "python"
///
/// let proc2 = new_process(2, "python3", "/usr/bin/python3", 75.0, 512, ProcessStatus::Running);
/// assert(!rule_matches_process(rule, proc2));  // No match: 75% <= 80%
///
/// let proc3 = new_process(3, "java", "/usr/bin/java", 95.0, 512, ProcessStatus::Running);
/// assert(!rule_matches_process(rule, proc3));  // No match: name doesn't contain "python"
/// ```
fun rule_matches_process(rule: DetectionRule, proc: Process) -> bool {
    // Disabled rules never match
    if !rule.enabled {
        return false;
    }

    // Check CPU threshold (if enabled - non-zero)
    if rule.max_cpu_percent > 0.0 {
        if proc.cpu_usage <= rule.max_cpu_percent {
            return false;
        }
    }

    // Check memory threshold (if enabled - non-zero)
    if rule.max_memory_mb > 0 {
        if proc.memory_mb <= rule.max_memory_mb {
            return false;
        }
    }

    // Check name pattern (if specified - non-empty)
    if rule.name_pattern != "" {
        // Case-sensitive substring matching using contains()
        // Note: Future enhancement could add case-insensitive matching
        if !proc.name.contains(rule.name_pattern) {
            return false;
        }
    }

    // Check cmdline pattern (if specified - non-empty)
    if rule.cmdline_pattern != "" {
        if !proc.cmdline.contains(rule.cmdline_pattern) {
            return false;
        }
    }

    // All conditions passed
    true
}

/// Formats a DetectionRule as a human-readable string for display.
///
/// Creates a compact string representation suitable for logging and UI display.
/// Includes rule name, priority, active thresholds, patterns, and enabled status.
///
/// # Arguments
/// * `rule` - The DetectionRule to format
///
/// # Returns
/// A formatted string with the structure:
/// `"Rule: <name> [<priority>] <thresholds> <patterns> (<status>)"`
///
/// # Format Details
/// * Name and priority are always included
/// * Thresholds only shown if > 0 (enabled)
/// * Patterns only shown if non-empty
/// * Status shows "enabled" or "disabled"
///
/// # Example
/// ```
/// let rule1 = new_detection_rule("CPU Hog", Priority::High, 80.0, 0, "python", "", true);
/// let output1 = format_rule(rule1);
/// // output1 == "Rule: CPU Hog [High] CPU>threshold pattern:python (enabled)"
///
/// let rule2 = new_detection_rule("Memory Hog", Priority::Medium, 0.0, 4096, "", "", false);
/// let output2 = format_rule(rule2);
/// // output2 == "Rule: Memory Hog [Medium] MEM>threshold (disabled)"
/// ```
fun format_rule(rule: DetectionRule) -> String {
    let priority_str = priority_to_string(rule.priority);
    let enabled_str = if rule.enabled { "enabled" } else { "disabled" };

    // Build the string piece by piece
    let mut result = "Rule: ";
    result = result + rule.name;
    result = result + " [";
    result = result + priority_str;
    result = result + "]";

    // Add CPU threshold if set
    if rule.max_cpu_percent > 0.0 {
        result = result + " CPU>";
        // Convert f64 to string - Ruchy should support this
        result = result + "threshold";  // Simplified for now
    }

    // Add memory threshold if set
    if rule.max_memory_mb > 0 {
        result = result + " MEM>";
        result = result + "threshold";  // Simplified for now
    }

    // Add name pattern if set
    if rule.name_pattern != "" {
        result = result + " pattern:";
        result = result + rule.name_pattern;
    }

    result = result + " (";
    result = result + enabled_str;
    result = result + ")";

    result
}

/// Creates a new Config instance with the given values.
///
/// This constructor does NOT validate inputs. Use `is_valid_config()` after
/// creation to ensure all field values are valid.
///
/// # Arguments
/// * `check_interval` - How often to scan processes (seconds)
/// * `rules` - Array of DetectionRule instances to apply
/// * `dry_run` - If true, log only (don't terminate)
/// * `log_file` - Path to log file
/// * `grace_period` - Seconds between SIGTERM and SIGKILL
///
/// # Returns
/// A Config instance with all fields set
///
/// # Example
/// ```
/// let empty_rules: [DetectionRule] = [];
/// let config = new_config(
///     60,      // Check every minute
///     empty_rules,
///     false,   // Real mode (not dry-run)
///     "/var/log/reaper.log",
///     5        // 5 second grace period
/// );
/// assert(is_valid_config(config), "Config should be valid");
/// ```
fun new_config(check_interval: i64, rules: [DetectionRule], dry_run: bool, log_file: String, grace_period: i64) -> Config {
    Config {
        check_interval_secs: check_interval,
        rules: rules,
        dry_run: dry_run,
        log_file: log_file,
        grace_period_secs: grace_period,
    }
}

/// Validates that a Config has valid field values.
///
/// Checks that all configuration fields contain valid values according to
/// the Config specification. This should be called after construction or
/// modification to ensure configuration integrity.
///
/// # Arguments
/// * `config` - The Config to validate
///
/// # Returns
/// * `true` if all validations pass
/// * `false` if any validation fails
///
/// # Validation Rules
/// * **Check interval**: Must be > 0 seconds
///   - Typical range: 10-300 seconds
///   - Too short (< 10) wastes CPU, too long (> 300) misses rogue processes
/// * **Log file**: Must be non-empty
///   - Empty path would make logging impossible
///   - Path validity not checked (filesystem-dependent)
/// * **Grace period**: Must be >= 0 seconds
///   - 0 means send SIGKILL immediately (no grace)
///   - Typical range: 3-10 seconds
/// * **Rules array**: No validation
///   - Empty array is valid (no detections will occur)
///   - Individual rules should be validated separately
///
/// # Example
/// ```
/// // Valid config
/// let empty_rules: [DetectionRule] = [];
/// let valid = new_config(60, empty_rules, false, "/var/log/reaper.log", 5);
/// assert(is_valid_config(valid));
///
/// // Invalid config (zero interval)
/// let invalid = new_config(0, empty_rules, false, "/var/log/reaper.log", 5);
/// assert(!is_valid_config(invalid));
///
/// // Valid config with zero grace period (immediate SIGKILL)
/// let immediate = new_config(60, empty_rules, false, "/var/log/reaper.log", 0);
/// assert(is_valid_config(immediate));
/// ```
fun is_valid_config(config: Config) -> bool {
    // Check interval must be positive
    if config.check_interval_secs <= 0 {
        return false;
    }

    // Log file must be non-empty
    if config.log_file == "" {
        return false;
    }

    // Grace period must be non-negative
    if config.grace_period_secs < 0 {
        return false;
    }

    true
}

/// Formats a Config as a human-readable string for display.
///
/// Creates a compact string representation suitable for logging and UI display.
/// Includes all configuration fields in a standardized format.
///
/// # Arguments
/// * `config` - The Config to format
///
/// # Returns
/// A formatted string with the structure:
/// `"Config[interval=<secs>, rules=<count>, dry_run=<bool>, log=<path>, grace=<secs>]"`
///
/// # Format Details
/// * All fields are included
/// * Times shown with 's' suffix (seconds)
/// * Dry-run shown as "true" or "false"
/// * Log path shown verbatim
///
/// # Example
/// ```
/// let empty_rules: [DetectionRule] = [];
/// let config = new_config(60, empty_rules, false, "/var/log/reaper.log", 5);
/// let output = format_config(config);
/// // output == "Config[interval=secs, rules=count, dry_run=false, log=/var/log/reaper.log, grace=secs]"
/// // Note: Numeric values simplified due to lack of i64->String conversion
/// ```
fun format_config(config: Config) -> String {
    let mut result = "Config[interval=";
    result = result + "secs";  // Simplified - would need i64->String conversion
    result = result + ", rules=";
    result = result + "count";  // Simplified - would need array length
    result = result + ", dry_run=";
    result = result + if config.dry_run { "true" } else { "false" };
    result = result + ", log=";
    result = result + config.log_file;
    result = result + ", grace=";
    result = result + "secs";  // Simplified
    result = result + "]";
    result
}

// ============================================================================
// TESTS - Process Struct (All tests should PASS after REFACTOR)
// ============================================================================

/// Test basic Process creation and field access.
/// Verifies that struct fields are correctly set and accessible.
#[test]
fun test_process_creation() {
    // Create a valid process with typical values
    let proc = new_process(
        1234,
        "test_process",
        "/usr/bin/test",
        45.5,
        256,
        ProcessStatus::Running
    );

    // Verify fields are set correctly
    assert(proc.pid == 1234, "Process PID should be 1234");
    assert(proc.name == "test_process", "Process name should be 'test_process'");
    assert(proc.cmdline == "/usr/bin/test", "Process cmdline should be '/usr/bin/test'");
    assert(proc.cpu_usage == 45.5, "Process CPU usage should be 45.5");
    assert(proc.memory_mb == 256, "Process memory should be 256 MB");
    // Note: Can't easily test enum equality yet, skip for now
}

/// Test validation accepts processes with positive PIDs.
/// Valid PIDs should pass validation.
#[test]
fun test_process_validation_positive_pid() {
    // Create process with valid positive PID
    let valid_proc = new_process(
        1234,
        "valid",
        "/bin/valid",
        0.0,
        100,
        ProcessStatus::Running
    );

    assert(is_valid_process(valid_proc), "Process with positive PID should be valid");
}

/// Test validation rejects processes with negative PIDs.
/// PIDs must be positive (> 0), so negative values should fail.
#[test]
fun test_process_validation_negative_pid() {
    // Create process with invalid negative PID
    let invalid_proc = new_process(
        -1,
        "invalid",
        "/bin/invalid",
        0.0,
        100,
        ProcessStatus::Running
    );

    assert(!is_valid_process(invalid_proc), "Process with negative PID should be invalid");
}

/// Test validation rejects processes with CPU usage > 100%.
/// CPU usage must be in range [0.0, 100.0].
#[test]
fun test_process_validation_cpu_range() {
    // Create process with CPU usage out of range (> 100%)
    let invalid_cpu = new_process(
        1234,
        "cpu_hog",
        "/bin/hog",
        150.0,  // Invalid: > 100.0
        100,
        ProcessStatus::Running
    );

    assert(!is_valid_process(invalid_cpu), "Process with CPU > 100% should be invalid");
}

/// Test validation rejects processes with negative memory.
/// Memory usage must be non-negative (>= 0).
#[test]
fun test_process_validation_negative_memory() {
    // Create process with invalid negative memory
    let invalid_mem = new_process(
        1234,
        "test",
        "/bin/test",
        50.0,
        -100,  // Invalid: negative memory
        ProcessStatus::Running
    );

    assert(!is_valid_process(invalid_mem), "Process with negative memory should be invalid");
}

/// Test format_process() returns non-empty string.
/// Formatted output is required for logging and display.
#[test]
fun test_process_format() {
    // Create a process for formatting
    let proc = new_process(
        9999,
        "format_test",
        "/usr/bin/format_test --arg",
        75.5,
        512,
        ProcessStatus::Running
    );

    // Format should include key information
    let formatted = format_process(proc);

    assert(formatted != "", "Formatted process should not be empty");
}

/// Test edge case: Process with 0% CPU usage.
/// Zero CPU is valid (idle processes).
#[test]
fun test_process_zero_cpu() {
    // Process with zero CPU usage should be valid (idle/sleeping)
    let proc = new_process(
        1234,
        "idle",
        "/bin/idle",
        0.0,
        100,
        ProcessStatus::Sleeping
    );

    assert(proc.cpu_usage == 0.0, "Zero CPU usage should be allowed");
}

/// Test edge case: Process with 100% CPU usage.
/// Maximum CPU usage is valid (busy processes).
#[test]
fun test_process_max_cpu() {
    // Process with 100% CPU usage should be valid (fully utilized)
    let proc = new_process(
        1234,
        "busy",
        "/bin/busy",
        100.0,
        100,
        ProcessStatus::Running
    );

    assert(proc.cpu_usage == 100.0, "100% CPU usage should be allowed");
}

/// Test edge case: Process with 0 MB memory usage.
/// Zero memory is valid (kernel threads have no userspace memory).
#[test]
fun test_process_zero_memory() {
    // Process with zero memory should be valid (e.g., kthreadd)
    let proc = new_process(
        2,
        "kthreadd",
        "",
        0.0,
        0,
        ProcessStatus::Running
    );

    assert(proc.memory_mb == 0, "Zero memory should be allowed");
}

// ============================================================================
// TESTS - Priority Enum (All tests should PASS after REFACTOR)
// ============================================================================

/// Test priority_to_string() correctly converts High variant.
/// Verifies string representation for logging and display.
#[test]
fun test_priority_high_to_string() {
    let high = Priority::High;
    let result = priority_to_string(high);
    assert(result == "high", "Priority::High should convert to 'high'");
}

/// Test priority_to_string() correctly converts Medium variant.
/// Verifies string representation for configuration output.
#[test]
fun test_priority_medium_to_string() {
    let medium = Priority::Medium;
    let result = priority_to_string(medium);
    assert(result == "medium", "Priority::Medium should convert to 'medium'");
}

/// Test priority_to_string() correctly converts Low variant.
/// Verifies string representation for user-facing displays.
#[test]
fun test_priority_low_to_string() {
    let low = Priority::Low;
    let result = priority_to_string(low);
    assert(result == "low", "Priority::Low should convert to 'low'");
}

/// Test priority_to_value() assigns correct numeric values for all variants.
/// Verifies the value mapping: High=3, Medium=2, Low=1.
/// Critical for sorting and comparison operations.
#[test]
fun test_priority_to_value() {
    let high = Priority::High;
    let medium = Priority::Medium;
    let low = Priority::Low;

    assert(priority_to_value(high) == 3, "High priority should have value 3");
    assert(priority_to_value(medium) == 2, "Medium priority should have value 2");
    assert(priority_to_value(low) == 1, "Low priority should have value 1");
}

/// Test is_higher_priority() correctly compares High vs Medium.
/// Verifies bidirectional comparison: High > Medium and !(Medium > High).
#[test]
fun test_priority_high_vs_medium() {
    let high = Priority::High;
    let medium = Priority::Medium;

    assert(is_higher_priority(high, medium), "High should be higher than Medium");
    assert(!is_higher_priority(medium, high), "Medium should not be higher than High");
}

/// Test is_higher_priority() correctly compares High vs Low.
/// Verifies maximum vs minimum priority comparison.
#[test]
fun test_priority_high_vs_low() {
    let high = Priority::High;
    let low = Priority::Low;

    assert(is_higher_priority(high, low), "High should be higher than Low");
    assert(!is_higher_priority(low, high), "Low should not be higher than High");
}

/// Test is_higher_priority() correctly compares Medium vs Low.
/// Verifies middle tier priority comparison.
#[test]
fun test_priority_medium_vs_low() {
    let medium = Priority::Medium;
    let low = Priority::Low;

    assert(is_higher_priority(medium, low), "Medium should be higher than Low");
    assert(!is_higher_priority(low, medium), "Low should not be higher than Medium");
}

/// Test is_higher_priority() with equal priorities returns false.
/// Verifies that same priority levels are not considered "higher".
/// Important for queue fairness and rule ordering.
#[test]
fun test_priority_equal() {
    let high1 = Priority::High;
    let high2 = Priority::High;

    assert(!is_higher_priority(high1, high2), "Equal priorities should return false");
}

// ============================================================================
// TESTS - DetectionRule Struct (expect these to FAIL in RED phase)
// ============================================================================

/// Test DetectionRule creation and field access
#[test]
fun test_detection_rule_creation() {
    let rule = new_detection_rule(
        "CPU Hog",
        Priority::High,
        80.0,
        1024,
        "python",
        "",
        true
    );

    assert(rule.name == "CPU Hog", "Rule name should be set");
    assert(rule.max_cpu_percent == 80.0, "CPU threshold should be set");
    assert(rule.max_memory_mb == 1024, "Memory threshold should be set");
    assert(rule.name_pattern == "python", "Name pattern should be set");
    assert(rule.enabled == true, "Enabled flag should be set");
}

/// Test is_valid_rule() accepts valid rules
#[test]
fun test_valid_detection_rule() {
    let valid_rule = new_detection_rule(
        "Valid Rule",
        Priority::Medium,
        90.0,
        2048,
        "",
        "",
        true
    );

    // This will FAIL in RED phase (is_valid_rule returns false)
    assert(is_valid_rule(valid_rule), "Valid rule should pass validation");
}

/// Test is_valid_rule() rejects rules with invalid CPU threshold
#[test]
fun test_invalid_cpu_threshold() {
    let invalid_rule = new_detection_rule(
        "Bad CPU",
        Priority::Medium,
        150.0,  // Invalid: > 100%
        1024,
        "",
        "",
        true
    );

    // This will FAIL in RED phase
    assert(!is_valid_rule(invalid_rule), "Rule with CPU > 100% should be invalid");
}

/// Test is_valid_rule() rejects rules with negative memory
#[test]
fun test_invalid_memory_threshold() {
    let invalid_rule = new_detection_rule(
        "Bad Memory",
        Priority::Medium,
        50.0,
        -100,  // Invalid: negative memory
        "",
        "",
        true
    );

    // This will FAIL in RED phase
    assert(!is_valid_rule(invalid_rule), "Rule with negative memory should be invalid");
}

/// Test rule_matches_process() for CPU threshold
#[test]
fun test_rule_matches_cpu_hog() {
    let rule = new_detection_rule(
        "CPU Hog",
        Priority::High,
        80.0,  // 80% CPU threshold
        0,     // No memory limit (0 = disabled)
        "",    // No name pattern
        "",    // No cmdline pattern
        true
    );

    let cpu_hog = new_process(
        1234,
        "cpu_hog",
        "/usr/bin/hog",
        95.0,  // 95% CPU - exceeds threshold
        512,
        ProcessStatus::Running
    );

    // This will FAIL in RED phase (rule_matches_process returns false)
    assert(rule_matches_process(rule, cpu_hog), "Process exceeding CPU threshold should match");
}

/// Test rule_matches_process() for memory threshold
#[test]
fun test_rule_matches_memory_hog() {
    let rule = new_detection_rule(
        "Memory Hog",
        Priority::High,
        0.0,    // No CPU limit
        1024,   // 1GB memory threshold
        "",
        "",
        true
    );

    let memory_hog = new_process(
        1234,
        "memory_hog",
        "/usr/bin/hog",
        50.0,
        2048,  // 2GB - exceeds threshold
        ProcessStatus::Running
    );

    // This will FAIL in RED phase
    assert(rule_matches_process(rule, memory_hog), "Process exceeding memory threshold should match");
}

/// Test rule_matches_process() for name pattern
#[test]
fun test_rule_matches_name_pattern() {
    let rule = new_detection_rule(
        "Python Killer",
        Priority::Medium,
        0.0,
        0,
        "python",  // Match processes with "python" in name
        "",
        true
    );

    let python_proc = new_process(
        1234,
        "python3.9",
        "/usr/bin/python3.9",
        50.0,
        512,
        ProcessStatus::Running
    );

    // This will FAIL in RED phase
    assert(rule_matches_process(rule, python_proc), "Process with matching name should match");
}

/// Test rule_matches_process() with disabled rule
#[test]
fun test_disabled_rule_no_match() {
    let disabled_rule = new_detection_rule(
        "Disabled",
        Priority::Low,
        50.0,
        1024,
        "",
        "",
        false  // Rule is disabled
    );

    let proc = new_process(
        1234,
        "test",
        "/usr/bin/test",
        95.0,  // Exceeds threshold but rule is disabled
        512,
        ProcessStatus::Running
    );

    // This will FAIL in RED phase
    assert(!rule_matches_process(disabled_rule, proc), "Disabled rule should not match any process");
}

/// Test format_rule() returns non-empty string
#[test]
fun test_format_detection_rule() {
    let rule = new_detection_rule(
        "Test Rule",
        Priority::High,
        80.0,
        1024,
        "test",
        "",
        true
    );

    let formatted = format_rule(rule);

    // This will FAIL in RED phase (format_rule returns empty string)
    assert(formatted != "", "Formatted rule should not be empty");
}

/// Test rule with zero thresholds (disabled thresholds)
#[test]
fun test_rule_zero_thresholds() {
    let rule = new_detection_rule(
        "Pattern Only",
        Priority::Low,
        0.0,  // 0 = no CPU limit
        0,    // 0 = no memory limit
        "suspicious",
        "",
        true
    );

    // Zero thresholds should be valid (means threshold is disabled)
    let proc = new_process(
        1234,
        "normal",
        "/usr/bin/normal",
        5.0,
        100,
        ProcessStatus::Running
    );

    // Should not match based on thresholds alone
    assert(rule.max_cpu_percent == 0.0, "Zero CPU threshold should be allowed");
    assert(rule.max_memory_mb == 0, "Zero memory threshold should be allowed");
}

// ============================================================================
// TESTS - Config Struct (expect these to FAIL in RED phase)
// ============================================================================

/// Test Config creation and field access
#[test]
fun test_config_creation() {
    let empty_rules: [DetectionRule] = [];
    let config = new_config(
        60,
        empty_rules,
        false,
        "/var/log/reaper.log",
        5
    );

    assert(config.check_interval_secs == 60, "Check interval should be set");
    assert(config.dry_run == false, "Dry run should be set");
    assert(config.log_file == "/var/log/reaper.log", "Log file should be set");
    assert(config.grace_period_secs == 5, "Grace period should be set");
}

/// Test is_valid_config() accepts valid configs
#[test]
fun test_valid_config() {
    let empty_rules: [DetectionRule] = [];
    let valid_config = new_config(
        60,
        empty_rules,
        false,
        "/var/log/reaper.log",
        5
    );

    // This will FAIL in RED phase (is_valid_config returns false)
    assert(is_valid_config(valid_config), "Valid config should pass validation");
}

/// Test is_valid_config() rejects zero check interval
#[test]
fun test_invalid_zero_check_interval() {
    let empty_rules: [DetectionRule] = [];
    let invalid_config = new_config(
        0,  // Invalid: must be > 0
        empty_rules,
        false,
        "/var/log/reaper.log",
        5
    );

    // This will FAIL in RED phase
    assert(!is_valid_config(invalid_config), "Config with zero interval should be invalid");
}

/// Test is_valid_config() rejects negative check interval
#[test]
fun test_invalid_negative_check_interval() {
    let empty_rules: [DetectionRule] = [];
    let invalid_config = new_config(
        -10,  // Invalid: must be > 0
        empty_rules,
        false,
        "/var/log/reaper.log",
        5
    );

    // This will FAIL in RED phase
    assert(!is_valid_config(invalid_config), "Config with negative interval should be invalid");
}

/// Test is_valid_config() rejects empty log file
#[test]
fun test_invalid_empty_log_file() {
    let empty_rules: [DetectionRule] = [];
    let invalid_config = new_config(
        60,
        empty_rules,
        false,
        "",  // Invalid: must be non-empty
        5
    );

    // This will FAIL in RED phase
    assert(!is_valid_config(invalid_config), "Config with empty log file should be invalid");
}

/// Test is_valid_config() rejects negative grace period
#[test]
fun test_invalid_negative_grace_period() {
    let empty_rules: [DetectionRule] = [];
    let invalid_config = new_config(
        60,
        empty_rules,
        false,
        "/var/log/reaper.log",
        -5  // Invalid: must be >= 0
    );

    // This will FAIL in RED phase
    assert(!is_valid_config(invalid_config), "Config with negative grace period should be invalid");
}

/// Test format_config() returns non-empty string
#[test]
fun test_format_config() {
    let empty_rules: [DetectionRule] = [];
    let config = new_config(
        60,
        empty_rules,
        false,
        "/var/log/reaper.log",
        5
    );

    let formatted = format_config(config);

    // This will FAIL in RED phase (format_config returns empty string)
    assert(formatted != "", "Formatted config should not be empty");
}

/// Test config with zero grace period (valid - means immediate SIGKILL)
#[test]
fun test_config_zero_grace_period() {
    let empty_rules: [DetectionRule] = [];
    let config = new_config(
        60,
        empty_rules,
        false,
        "/var/log/reaper.log",
        0  // Valid: 0 means immediate SIGKILL
    );

    // Zero grace period should be valid
    assert(config.grace_period_secs == 0, "Zero grace period should be allowed");
}

// ============================================================================
// MAIN
// ============================================================================

/// Main entry point for Reaper process watcher.
/// Currently in TDD development phase, demonstrating extreme TDD methodology.
fun main() {
    println("========================================");
    println("Reaper v0.2.0 - Rogue Process Watcher");
    println("Pure Ruchy v3.155.0 - TDD Implementation");
    println("========================================");
    println("");
    println("Status: REAPER-109 RED PHASE");
    println("Current: Writing tests for Config struct");
    println("");
    println("Completed Cycles:");
    println("  ✅ Process struct (full RED-GREEN-REFACTOR)");
    println("  ✅ Priority enum (full RED-GREEN-REFACTOR)");
    println("  ✅ DetectionRule struct (full RED-GREEN-REFACTOR)");
    println("");
    println("Current TDD Cycle (Config struct):");
    println("  [X] RED: Write failing tests");
    println("  [ ] GREEN: Make tests pass");
    println("  [ ] REFACTOR: Improve code quality");
    println("");
    println("Tests Added: 8 Config tests (expect FAILURES)");
    println("  - test_config_creation()");
    println("  - test_valid_config()");
    println("  - test_invalid_zero_check_interval()");
    println("  - test_invalid_negative_check_interval()");
    println("  - test_invalid_empty_log_file()");
    println("  - test_invalid_negative_grace_period()");
    println("  - test_format_config()");
    println("  - test_config_zero_grace_period()");
    println("");
    println("Total Tests: 35 (27 passing, 8 new failing)");
    println("Next: Run 'ruchy test' - expect FAILURES (RED phase)");
    println("========================================");
}
